#### 思路

把数据分为已排序和未排序两部分，从未排序数据中取出取出第一位依次跟已排序的数据比较，找到响应的位置插入。初始时，已排序部分就是第0位数据，具体过程可以看👇的图
![iamge](../picture/插入排序过程.jpeg)


#### 代码实现
```java
int[] insertSort(int[] data){
    //位排序部分
    for(int i=1;i<data.length;i++){
        int j = i-1;
        //待比较的数据
        int temp = data[i];
        //未排序部分
        for(;j>=0;j--){
            if(temp<data[j]){
                //向后移动一位
                data[j+1] = data[j];
            }
        }

        //插入数据
        data[j+1] = temp;
    }
    return data;
}
```

#### 分析
- 因为只用了几个临时变量的空间，空间复杂度为O(1)，所以插入排序是原地排序
- 在比较的过程中，对于相同的元素，不做位置交换。所以，排序前后相同元素的位前后关系不变，插入是稳定排序
- 时间复杂度为O(n^2)
- 上面的代码中，数据移动只需要1行赋值代码，而冒泡需要3行，大量数据下，这个性能提升也是很可观的，所以实际中插入排序比冒泡排序受欢迎